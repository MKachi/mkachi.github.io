---
title: Javascript 데이터 타입의 동작 과정
date: 2020-07-25
time: 22:05:40
tags: [javascript]
---

C와 C++같은 정적 타입의 언어들은 메모리 낭비를 최소화 하기 위해 데이터 타입별로 할당할 메모리 영역을 나누어 사용합니다.  
하지만 데이터 타입의 표현 범위가 벗어나게 될 경우 더 큰 자료형으로 타입을 변환하여 사용해야 합니다.  

메모리 용량이 과거보다 매우 커지게 된 시점에서 등장한 Javascript는 상대적으로 메모리 관리에 대한 압박에서 자유로워져  
`Number`의 경우 정수형인지 부동소수형인지 구분하지 않고 64Bit (1Bit는 부호+/-, 11Bit는 지수부, 52Bit는 가수부)의 메모리를 사용합니다.

## 데이터 할당

```javascript
var a
a = 'test'
var a = 'test'
```

자바스크립트에서의 데이터 할당은 다음과 같은 과정을 수행합니다.
1. 변수 영역에서 빈 공간을 확보
2. 확보한 공간의 식별자를 a로 지정
3. 데이터 영역의 빈 공간에 문자열 test를 저장
4. 변수 영역의 a 식별자를 가진 공간에 데이터 영역에 할당된 주소를 저장  
   코드에 작성되어 있는 식별자 `a`는 변수 영역에 할당된 주소를 참조하고 있음

변수 영역에 값을 직접 대입하지 않고 위의 과정처럼 한 단계를 더 거치는 이유는 다음과 같습니다.

### 데이터 변환을 자유롭게 만들기 위함

`String`은 앞에서 설명한 `Number`와는 달리 가변적이므로 데이터가 변경 될 경우  
할당된 모든 정보를 모두 뒤로 옮기고 이동시킨 주소로 모든 식별자들의 정보를 연결해야 합니다.

하지만 식별자에 대한 데이터를 가진 변수 영역과 문자열 데이터를 가진 데이터 영역이 분리되어 있으면   
식별자에 대한 정보들을 모두 다시 연결할 필요없이 데이터 영역의 주소만 새로 바뀐 주소로 교환해주면 됩니다.

### 메모리를 효율적으로 사용하기 위함

만약 500개의 변수를 생성하여 모든 변수에 같은 데이터를 할당해야 하고 변수 영역과 데이터 영역이 분리되지 않았을 경우  
일일이 모든 변수 공간을 할당하여 같은 데이터를 집어넣어야 합니다.

만약 `Number`를 할당할 경우 4000Byte (500 * 8Bit * 변수 영역의 크기)를 사용해야 합니다.  
하지만 변수 영역과 데이터 영역이 분리되어 있을 경우

변수 영역만 500개를 할당하고  `Number`가 할당된 데이터 영역을 참조하면 됩니다.  
그렇게 되면 (500 * 변수 영역의 크기 + 8Bit)만 할당하면 되므로 데이터에 대한 처리 효율이 높아집니다.

또한 Javascript에서 변수에 값을 할당할 경우 데이터 영역에 할당하려는 값과 같은 데이터가 있는지 탐색하고  
없을 경우 데이터 영역을 새로 만들어 변수 영역에 연결시킵니다.

## 불변값

`Primitive Type`들은 모두 불변값입니다.  
불변값을 상수와 오해하기가 쉬운데 변수와 상수를 구분 짓는 것은 변수 영역의 데이터 주소를 재할당할 수 있는지에 대한 여부가 차이점 입니다.

불변값은 데이터 영역의 할당된 값이 절대로 변경되지 않는다는 것입니다.

위에서 설명하였듯 변수에 값을 새로 할당하게 될 경우 데이터 영역에 같은 값을 가진 데이터가 있는지 탐색하고  
만약 없을 경우 데이터 영역을 새로 할당하게 됩니다.

이 과정에서 데이터 영역의 값을 변경하는 것이 아닌 새로운 데이터 영역을 할당하기 때문에 데이터 영역에 할당된 값을  
변하지 않는값 `불변값`이라고 부릅니다.

## 가변값

Javascript에서 `Reference Type`들은 불변값 데이터의 집합입니다.  
`Reference Type`들의 데이터 영역은 참조하고 있는 불변값의 변수 영역 주소을 참조하게 됩니다.

만약 `Reference Type`이 참조하고 있는 불변값들의 데이터 영역 참조 주소를 변경하게 되면  
`Reference Type`의 데이터 영역에서 지니고 있는 참조 주소 값을 변경하게 됩니다.

즉 `Reference Type`의 데이터 영역의 값이 변경되었기 때문에 가변성을 지닙니다.

하지만 `Reference Type`의 데이터가 변경될 경우  
`Reference Type`의 새로운 데이터 영역을 만들어 변수 영역에 연결해주는 도구를 만들어 사용한다면 불변성을 확보할 수 있습니다.

## 얕은 복사와 깊은 복사

Javascript에서의 `얕은 복사`는 `Reference Type`의 데이터 영역만을 새롭게 만들어 다른 불변값들을 연결해주는 것이고  
`깊은 복사`는 `Reference Type`의 데이터 영역뿐만 아니라 `Reference Type`의 데이터 영역에서 참조하고 있는 불변값들의  
변수 영역 또한 복사하는 것입니다.

만약 참조하고 있는 것이 `Reference Type`일 경우  
그 `Reference Type`의 데이터 영역 또한 위와 같은 작업을 수행하여 **깊게** 복사를 수행합니다.

> 불변값은 값이 변경될 경우 새롭게 할당되므로 데이터 영역을 복제하는 것이 아닌 변수 영역을 복제합니다.

## undefined와 null

### undefined와 null의 차이

`undefined`는 Javascript 엔진이 반환하는 값이 '없음'을 나타내는 문자입니다.  
`null`은 사용자가 명시적으로 값이 '없음'을 나타내기 위한 값입니다.

사용자가 값이 없음을 표현할 때 `null`만을 사용한다면  
`undefined`는 Javascript 엔진에서 반환하는 값이라는 값이라는 것을 명확히 할 수 있습니다.  
때문에 사용자가 명시적으로 값이 없음을 표현할 때에는 `undefined`를 사용하지 않는 편이 좋습니다.

### null의 함정

`null`을 사용할 때에는 주의해야할 점이 있습니다.

```javascript
console.log(typeof null) // object
console.log(typeof undefined) // undefined
```

`typeof`를 사용하였을 때 `null`은 `object`를 반환하는 점입니다.  
이는 Javascript의 자체 버그입니다.

따라서 `typeof`로 변수의 값이 `null`인지 판별해서는 안됩니다.

> 참고 : https://2ality.com/2013/10/typeof-null

이러한 버그를 고치지 않는 이유는 기존에 작성한 코드들이 이에 맞게 작성되어 있어
하위 호환 유지를 위해 고치지 않고 있다고 합니다....

> 참고 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/null  
> MDN에서는 단순히 '(하위호환 유지를 위해 "null"이 아님)' 이 주석만 남아있어 위의 주소도 함께 참고해주시면 좋을것 같습니다.
